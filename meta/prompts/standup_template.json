{
  "meta": {
    "template_version": "1.0.0",
    "created": "2025-10-27",
    "purpose": "Greenfield standup template for any schema version",
    "usage": "Copy this file to v{VERSION}_standup.json, replace {VERSION} placeholders, execute steps",
    "schema_version_placeholder": "{VERSION}"
  },
  "target": {
    "schema_version": "{VERSION}",
    "namespace": "v{VERSION_UNDERSCORE}",
    "objective": "Build minimal schema-driven generator that passes MCP strict validation for schema {VERSION}",
    "success_criteria": "Asset generated by labs.v{VERSION_UNDERSCORE}.generate_asset() passes MCPClient.validate(strict=True)"
  },
  "prerequisites": {
    "description": "What must exist before running this standup",
    "mcp_transport": "TCP only - single connectivity path for simplicity",
    "required": [
      "MCP server accessible via TCP (localhost:3000 default)",
      "MCP schema {VERSION} available via MCP protocol",
      "Python 3.11+ environment",
      "Base repo structure (labs/mcp/, requirements.txt, tests/conftest.py)"
    ],
    "verify": [
      "MCP server running: curl http://localhost:3000/health (or equivalent)",
      "pytest tests/test_mcp.py passes (TCP client works)",
      "MCP schema {VERSION} fetchable via load_schema_bundle(version='{VERSION}')",
      "Git clean working directory"
    ]
  },
  "principles": {
    "core": [
      "MCP is single source of truth - never hardcode schema structures",
      "Schema-driven generation - read structure from MCP, build assets from schema",
      "Test-first development - write test, make it pass, then extend",
      "Version confinement - all {VERSION} code in labs.v{VERSION_UNDERSCORE} namespace",
      "Self-contained - {VERSION} has own environment, tests, output directory",
      "Minimal first - prove validation passes before adding features",
      "Single transport - TCP only, no stdio/socket complexity"
    ],
    "constraints": [
      "No hardcoded templates - generators read schema dynamically",
      "No normalization layers - output correct structure initially",
      "No version mixing - imports must be explicit (from labs.v{VERSION_UNDERSCORE})",
      "No disk schema caching as authority - MCP is always truth"
    ]
  },
  "steps": [
    {
      "step": 1,
      "phase": "create_namespace",
      "description": "Create version-confined namespace for schema {VERSION}",
      "actions": [
        {
          "action": "create_code_namespace",
          "commands": [
            "mkdir -p labs/v{VERSION_UNDERSCORE}",
            "touch labs/v{VERSION_UNDERSCORE}/__init__.py",
            "touch labs/v{VERSION_UNDERSCORE}/generator.py"
          ],
          "result": "labs/v{VERSION_UNDERSCORE}/ namespace created"
        },
        {
          "action": "create_test_namespace",
          "commands": [
            "mkdir -p tests/v{VERSION_UNDERSCORE}",
            "touch tests/v{VERSION_UNDERSCORE}/__init__.py",
            "touch tests/v{VERSION_UNDERSCORE}/test_validation.py"
          ],
          "result": "tests/v{VERSION_UNDERSCORE}/ namespace created"
        },
        {
          "action": "create_output_directory",
          "commands": [
            "mkdir -p meta/output/v{VERSION_UNDERSCORE}"
          ],
          "result": "Isolated output directory for {VERSION} telemetry"
        },
        {
          "action": "create_environment_file",
          "file": ".env.{VERSION}",
          "content": [
            "# Schema version {VERSION} environment",
            "LABS_SCHEMA_VERSION={VERSION}",
            "LABS_SCHEMA_RESOLUTION=inline",
            "LABS_SCHEMA_NAMESPACE=v{VERSION_UNDERSCORE}",
            "",
            "# MCP connectivity (TCP only)",
            "LABS_MCP_TRANSPORT=tcp",
            "LABS_MCP_HOST=localhost",
            "LABS_MCP_PORT=3000",
            "",
            "# Output",
            "LABS_OUTPUT_DIR=meta/output/v{VERSION_UNDERSCORE}/",
            "LABS_LOG_LEVEL=INFO"
          ],
          "result": "Version-specific environment configuration"
        }
      ],
      "verification": [
        "ls labs/v{VERSION_UNDERSCORE}/ shows __init__.py, generator.py",
        "ls tests/v{VERSION_UNDERSCORE}/ shows __init__.py, test_validation.py",
        "ls .env.{VERSION} exists"
      ]
    },
    {
      "step": 2,
      "phase": "write_validation_test_first",
      "description": "TDD: Write the test before implementation - this defines success",
      "rationale": "Test-first ensures we know what success looks like before coding",
      "file": "tests/v{VERSION_UNDERSCORE}/test_validation.py",
      "template": [
        "\"\"\"Validation tests for schema {VERSION} generator.\"\"\"",
        "",
        "from labs.mcp.client import MCPClient",
        "from labs.v{VERSION_UNDERSCORE}.generator import generate_asset, SCHEMA_VERSION",
        "",
        "",
        "def test_generator_passes_mcp_strict_validation():",
        "    \"\"\"",
        "    THE test: Prove generator produces valid {VERSION} assets.",
        "    ",
        "    Success criteria:",
        "    1. Generator creates asset from prompt",
        "    2. Asset has version = '{VERSION}'",
        "    3. MCP strict validation passes",
        "    \"\"\"",
        "    # Arrange",
        "    client = MCPClient(schema_version=SCHEMA_VERSION)",
        "    prompt = 'peaceful ocean waves'",
        "    ",
        "    # Act",
        "    asset = generate_asset(client, prompt)",
        "    ",
        "    # Assert: Version confinement",
        "    assert 'version' in asset, \"Asset missing version field\"",
        "    assert asset['version'] == SCHEMA_VERSION, \\",
        "        f\"Expected version {SCHEMA_VERSION}, got {asset['version']}\"",
        "    ",
        "    # Assert: MCP strict validation (THE test)",
        "    result = client.validate(asset, strict=True)",
        "    assert result['valid'] is True, \\",
        "        f\"MCP validation failed: {result.get('errors', [])}\"",
        "    ",
        "    print(f\"âœ… Generated valid {SCHEMA_VERSION} asset\")",
        "    print(f\"Asset keys: {list(asset.keys())}\")"
      ],
      "verification": [
        "pytest tests/v{VERSION_UNDERSCORE}/test_validation.py --collect-only (test discovered)",
        "Test will fail - generator doesn't exist yet (expected)"
      ]
    },
    {
      "step": 3,
      "phase": "implement_namespace_init",
      "description": "Set up namespace with version lock and environment loading",
      "file": "labs/v{VERSION_UNDERSCORE}/__init__.py",
      "template": [
        "\"\"\"Synesthetic Labs - Schema version {VERSION} namespace.\"\"\"",
        "",
        "import os",
        "from pathlib import Path",
        "from dotenv import load_dotenv",
        "",
        "SCHEMA_VERSION = '{VERSION}'",
        "",
        "# Load version-specific environment",
        "_env_file = Path(__file__).parent.parent.parent / f'.env.{SCHEMA_VERSION}'",
        "if _env_file.exists():",
        "    load_dotenv(_env_file)",
        "",
        "# Verify schema version lock",
        "_loaded_version = os.getenv('LABS_SCHEMA_VERSION')",
        "if _loaded_version and _loaded_version != SCHEMA_VERSION:",
        "    raise ValueError(",
        "        f'Schema version mismatch: '",
        "        f'namespace={SCHEMA_VERSION}, env={_loaded_version}'",
        "    )",
        "",
        "from .generator import generate_asset",
        "",
        "__all__ = ['generate_asset', 'SCHEMA_VERSION']"
      ],
      "rationale": "Namespace init enforces version lock and loads isolated environment"
    },
    {
      "step": 4,
      "phase": "implement_schema_driven_generator",
      "description": "Build generator that reads schema from MCP and constructs valid assets",
      "file": "labs/v{VERSION_UNDERSCORE}/generator.py",
      "template": [
        "\"\"\"Schema-driven generator for synesthetic assets (schema {VERSION}).\"\"\"",
        "",
        "from typing import Any, Dict",
        "from labs.mcp.client import load_schema_bundle",
        "",
        "SCHEMA_VERSION = '{VERSION}'",
        "",
        "",
        "def generate_asset(mcp_client, prompt: str) -> Dict[str, Any]:",
        "    \"\"\"",
        "    Generate synesthetic asset for schema {VERSION}.",
        "    ",
        "    Args:",
        "        mcp_client: MCPClient instance for schema fetching/validation",
        "        prompt: User prompt describing desired asset",
        "    ",
        "    Returns:",
        "        Asset dict matching schema {VERSION} structure",
        "    \"\"\"",
        "    # Fetch schema from MCP - single source of truth",
        "    schema = load_schema_bundle(client=mcp_client, version=SCHEMA_VERSION)",
        "    ",
        "    # Extract top-level structure",
        "    required_fields = schema.get('required', [])",
        "    properties = schema.get('properties', {})",
        "    ",
        "    # Build asset with required fields",
        "    asset = {",
        "        '$schema': f'https://synesthetic.dev/schemas/{SCHEMA_VERSION}/synesthetic-asset.schema.json',",
        "        'version': SCHEMA_VERSION",
        "    }",
        "    ",
        "    # Add each required field by reading schema structure",
        "    for field_name in required_fields:",
        "        if field_name in ['$schema', 'version']:",
        "            continue  # Already added",
        "        ",
        "        field_schema = properties.get(field_name, {})",
        "        asset[field_name] = _build_field_from_schema(field_schema, field_name, prompt)",
        "    ",
        "    return asset",
        "",
        "",
        "def _build_field_from_schema(field_schema: dict, field_name: str, prompt: str) -> Any:",
        "    \"\"\"",
        "    Build field value by reading schema structure.",
        "    ",
        "    Handles anyOf by picking first valid option.",
        "    Reads nested required fields from schema.",
        "    \"\"\"",
        "    # Handle anyOf: pick first valid option",
        "    if 'anyOf' in field_schema:",
        "        option_schema = field_schema['anyOf'][0]",
        "    else:",
        "        option_schema = field_schema",
        "    ",
        "    # Check if field is object with nested structure",
        "    if option_schema.get('type') == 'object':",
        "        return _build_object_from_schema(option_schema, field_name, prompt)",
        "    ",
        "    # Check if field is array",
        "    if option_schema.get('type') == 'array':",
        "        return _build_array_from_schema(option_schema, field_name, prompt)",
        "    ",
        "    # Primitive field - return minimal valid value",
        "    return _minimal_value_for_type(option_schema.get('type'), field_name, prompt)",
        "",
        "",
        "def _build_object_from_schema(obj_schema: dict, field_name: str, prompt: str) -> dict:",
        "    \"\"\"Build nested object by reading schema structure.\"\"\"",
        "    obj = {}",
        "    required = obj_schema.get('required', [])",
        "    properties = obj_schema.get('properties', {})",
        "    ",
        "    for prop_name in required:",
        "        prop_schema = properties.get(prop_name, {})",
        "        obj[prop_name] = _build_field_from_schema(prop_schema, prop_name, prompt)",
        "    ",
        "    return obj",
        "",
        "",
        "def _build_array_from_schema(array_schema: dict, field_name: str, prompt: str) -> list:",
        "    \"\"\"Build array with minimal valid item.\"\"\"",
        "    items_schema = array_schema.get('items', {})",
        "    # Return array with one minimal item",
        "    return [_build_field_from_schema(items_schema, f'{field_name}_item', prompt)]",
        "",
        "",
        "def _minimal_value_for_type(field_type: str, field_name: str, prompt: str) -> Any:",
        "    \"\"\"Return minimal valid value for primitive types.\"\"\"",
        "    if field_type == 'string':",
        "        return prompt[:100] if 'description' in field_name.lower() else field_name",
        "    elif field_type == 'number' or field_type == 'integer':",
        "        return 0",
        "    elif field_type == 'boolean':",
        "        return False",
        "    else:",
        "        return None"
      ],
      "rationale": "Generator reads schema structure and builds assets dynamically - no hardcoded templates"
    },
    {
      "step": 5,
      "phase": "tdd_iteration",
      "description": "Run test, examine failures, fix generator, repeat until passing",
      "process": [
        {
          "iteration": 1,
          "run": "pytest tests/v{VERSION_UNDERSCORE}/test_validation.py -v",
          "expected": "Test fails - MCP validation errors",
          "action": "Read error messages, identify missing/wrong fields",
          "fix": "Update generator.py to match schema structure for those fields"
        },
        {
          "iteration": 2,
          "run": "pytest tests/v{VERSION_UNDERSCORE}/test_validation.py -v",
          "expected": "Different validation errors (progress)",
          "action": "Examine next set of errors",
          "fix": "Fix generator to handle anyOf correctly, nested objects, etc."
        },
        {
          "iteration": "N",
          "run": "pytest tests/v{VERSION_UNDERSCORE}/test_validation.py -v",
          "expected": "PASSED - MCP validation succeeds",
          "action": "Celebrate! Minimal implementation works",
          "next": "Move to step 6"
        }
      ],
      "debugging_tips": [
        "Print schema structure: print(json.dumps(schema, indent=2))",
        "Print generated asset: print(json.dumps(asset, indent=2))",
        "Compare: does asset structure match schema['required']?",
        "Check anyOf: are we picking valid option? reading its required fields?",
        "Validate incrementally: comment out fields, add one at a time"
      ]
    },
    {
      "step": 6,
      "phase": "verify_minimal_success",
      "description": "Confirm all success criteria met before extending",
      "checklist": [
        {
          "criterion": "Test passes",
          "verify": "pytest tests/v{VERSION_UNDERSCORE}/test_validation.py -v shows PASSED",
          "status": "required"
        },
        {
          "criterion": "MCP validation",
          "verify": "client.validate(asset, strict=True)['valid'] == True",
          "status": "required"
        },
        {
          "criterion": "Version confinement",
          "verify": "asset['version'] == '{VERSION}'",
          "status": "required"
        },
        {
          "criterion": "Schema-driven",
          "verify": "grep -r 'FRAGMENT_SHADER\\|_UNIFORMS\\|hardcoded' labs/v{VERSION_UNDERSCORE}/ returns nothing",
          "status": "required"
        },
        {
          "criterion": "Namespace isolation",
          "verify": "All {VERSION} code in labs.v{VERSION_UNDERSCORE}/, tests in tests.v{VERSION_UNDERSCORE}/",
          "status": "required"
        },
        {
          "criterion": "No cross-imports",
          "verify": "No imports from other version namespaces",
          "status": "required"
        }
      ],
      "on_success": "Commit: 'feat: schema {VERSION} minimal generator passing MCP validation'",
      "on_failure": "Return to step 5, continue TDD iteration"
    },
    {
      "step": 7,
      "phase": "extend_incrementally",
      "description": "Only after minimal works, add features one at a time",
      "phases": [
        {
          "phase": "7.1",
          "name": "rich_content_generation",
          "description": "Add external LLM (Azure/Gemini) for rich shader code, descriptions",
          "approach": "LLM generates content, schema-driven structure remains",
          "test_first": "tests/v{VERSION_UNDERSCORE}/test_external_content.py",
          "rationale": "LLM for content quality, schema for structure correctness"
        },
        {
          "phase": "7.2",
          "name": "multi_component_support",
          "description": "Support all components: shader, tone, control, haptic, modulations",
          "approach": "Extend generator to read all component schemas from MCP",
          "test_first": "tests/v{VERSION_UNDERSCORE}/test_multi_component.py",
          "rationale": "Each component schema-driven using same pattern"
        },
        {
          "phase": "7.3",
          "name": "cli_interface",
          "description": "Add CLI for version {VERSION}",
          "command": "labs generate --version {VERSION} <prompt>",
          "test_first": "tests/v{VERSION_UNDERSCORE}/test_cli.py"
        },
        {
          "phase": "7.4",
          "name": "critic_review",
          "description": "Add critic agent for asset review/improvement",
          "approach": "Critic validates against MCP, suggests improvements",
          "test_first": "tests/v{VERSION_UNDERSCORE}/test_critic.py"
        }
      ],
      "rule": "Each phase requires passing tests before proceeding to next"
    }
  ],
  "anti_patterns": {
    "never_do": [
      {
        "pattern": "Hardcode schema structures",
        "example": "fragment_shader = {'type': 'string', 'minLength': 1}",
        "why": "Schema changes break code, not maintainable",
        "instead": "Read from MCP schema: field_schema = properties['fragment_shader']"
      },
      {
        "pattern": "Cache schema to disk as authority",
        "example": "json.load(open('schemas/{VERSION}.json'))",
        "why": "Creates divergence, disk != MCP truth",
        "instead": "Always load_schema_bundle(client, version='{VERSION}')"
      },
      {
        "pattern": "Add features before validation passes",
        "example": "Implement critic before generator validates",
        "why": "Building on broken foundation",
        "instead": "Prove step 6 success before step 7"
      },
      {
        "pattern": "Mix schema versions in one namespace",
        "example": "if version == '0.7.3': ... elif version == '0.7.4': ...",
        "why": "Version mixing bugs, unmaintainable",
        "instead": "Separate namespace per version: labs.v0_7_3, labs.v0_7_4"
      },
      {
        "pattern": "Import from version-ambiguous paths",
        "example": "from labs.generator import generate_asset",
        "why": "Which version? Implicit = bugs",
        "instead": "from labs.v{VERSION_UNDERSCORE} import generate_asset"
      }
    ]
  },
  "success_definition": {
    "minimal_viable": "test_validation.py passes with MCP strict validation",
    "production_ready": "All phase 7 extensions complete with passing tests",
    "maintainable": "New team member can add {VERSION+1} by copying this template"
  },
  "template_usage": {
    "for_new_version": [
      "1. Copy meta/prompts/standup_template.json to meta/prompts/v{NEW_VERSION}_standup.json",
      "2. Replace {VERSION} with actual version (e.g., 0.7.4)",
      "3. Replace {VERSION_UNDERSCORE} with underscored version (e.g., 0_7_4)",
      "4. Execute steps 1-6 following TDD process",
      "5. Verify success criteria met",
      "6. Commit minimal working state",
      "7. Execute step 7 phases incrementally"
    ],
    "placeholders": {
      "{VERSION}": "Schema version with dots (e.g., 0.7.3, 0.7.4, 1.0.0)",
      "{VERSION_UNDERSCORE}": "Schema version with underscores (e.g., 0_7_3, 0_7_4, 1_0_0)",
      "{NEW_VERSION}": "Next schema version to implement"
    }
  }
}
